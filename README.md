文件命名规则：类型-问题-算法-题号-名称.md

TODO: 总结板子+复杂度

## 问题：拿物品，在体积限制内，能拿的最大价值是多少（背包问题）

### 每件物品能拿0/1件（01背包问题）

### 每件物品能拿无数件（完全背包问题）
**思路**  
状态表示：f[i][j]表示只考虑前i件物品，总体积<=j的所有方案中，最大价值  
状态计算：按照第i件物品拿0/1/2/.../k个来分类  
优化1：用f[i][j - v[i]]来优化时间（不用枚举k了）  
优化2：用滚动数组来优化空间  
**例子**  
279. n被写成平方和，最短要多少个数  
转化思路：n是背包大小，1,4,9,16是物品体积，1是物品价值，求最小价值

---

## 整体思路：先枚举，然后再优化

**84-直方图里，最大矩形面积**  
两种枚举思路：
1. 枚举矩形左上右下端点，找区间最小
2. 枚举矩形高度，找左右第一个比他低的位置（识别单调栈）

**85-01矩阵里，最大的由1组成的长方形**  
两种枚举思路：
1. 枚举矩形左上角和右下角位置，然后看里面是不是全1
2. 枚举矩形下边界，如果知道每个位置上面1的高度（识别dp），那就可以reduce成找直方图最大矩形面积问题

## 基础问题模型

求附近第一个比我大/小的数 -> 单调栈

求最优解，搜索空间很大（指数）-> DP
**例子**  
139. 给定字符串，能否拆分成给定单词表，不限使用次数  
暴力思路：n-1个空隙，每个都可以选择是否split，然后检查每一段是否在单词表里。指数复杂度（识别dp）
状态表示：f[i]代表0-i这个字串所有合法分解方案的集合，数值是集合是否为空
状态计算：按照这个字符串最后一次split的位置k分类，看f[k+1:i]是否在字典里，再看f[k]是否能被合法分解

注意：因为要看看f[k+1:i]是否在字典里，而unordered map不能对字符串做O(1)的查找，所以需要字符串哈希。字符串哈希最方便的计算是不断的append，而这里是不断的prepend，所以不是很理想。需要考虑反过来思考dp，也就是f[i]代表f[i:n-1]能否被合法分解，然后按照这个字符串第一次split的位置分类。

## 数学结论

四平方定理：正整数n一定能被写成4个平方数之和  
三平方定理：正整数n能被写成3个平方数之和 iff n != 4^a(8b+c)  
例子：279. n被写成平方和，最短要多少个数

## STL复杂度
unordered_set通常用来做hash，count是O(1)次的计算hash+compare。因此如果是字符串，其实需要O(len) 
https://www.appsloveworld.com/cplus/100/161/c-unordered-set-string-hash-time-complexity